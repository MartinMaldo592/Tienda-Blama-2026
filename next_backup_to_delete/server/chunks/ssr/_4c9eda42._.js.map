{"version":3,"sources":["../../../../node_modules/lucide-react/src/icons/check.ts","../../../../features/products/services/products.client.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]];\n\n/**\n * @component @name Check\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjAgNiA5IDE3bC01LTUiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/check\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Check = createLucideIcon('check', __iconNode);\n\nexport default Check;\n","import { supabase } from \"@/lib/supabaseClient\"\r\nimport type {\r\n    Category,\r\n    Product,\r\n    ProductSpecification,\r\n    ProductVariant,\r\n    ProductWithCategory,\r\n    SortValue,\r\n} from \"@/features/products/types\"\r\n\r\nexport async function listCategories(): Promise<Category[]> {\r\n    const { data, error } = await supabase.from(\"categorias\").select(\"*\").order(\"nombre\", { ascending: true })\r\n    if (error) {\r\n        console.error(\"Error fetching categories:\", error)\r\n        return []\r\n    }\r\n    return (data as Category[]) || []\r\n}\r\n\r\nexport type ListProductsParams = {\r\n    cat: string\r\n    q: string\r\n    sort: SortValue\r\n    min: string\r\n    max: string\r\n    stock: boolean\r\n    page: number\r\n    pageSize: number\r\n}\r\n\r\nexport type ListProductsResult = {\r\n    productos: Product[]\r\n    totalCount: number\r\n}\r\n\r\nexport async function listProducts(params: ListProductsParams): Promise<ListProductsResult> {\r\n    const q = (params.q || \"\").trim()\r\n    const min = params.min ? Number(params.min) : null\r\n    const max = params.max ? Number(params.max) : null\r\n\r\n    let productsQuery = supabase.from(\"productos\").select(\"*\", { count: \"exact\" })\r\n\r\n    if (params.cat !== \"all\") {\r\n        const categoryId = Number(params.cat)\r\n        if (Number.isFinite(categoryId) && categoryId > 0) {\r\n            productsQuery = productsQuery.eq(\"categoria_id\", categoryId)\r\n        } else {\r\n            const { data: catRow, error: catError } = await supabase\r\n                .from(\"categorias\")\r\n                .select(\"id\")\r\n                .eq(\"slug\", params.cat)\r\n                .maybeSingle()\r\n\r\n            if (!catError && catRow?.id) {\r\n                productsQuery = productsQuery.eq(\"categoria_id\", catRow.id)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (q) {\r\n        productsQuery = productsQuery.ilike(\"nombre\", `%${q}%`)\r\n    }\r\n\r\n    if (min !== null && Number.isFinite(min)) {\r\n        productsQuery = productsQuery.gte(\"precio\", min)\r\n    }\r\n\r\n    if (max !== null && Number.isFinite(max)) {\r\n        productsQuery = productsQuery.lte(\"precio\", max)\r\n    }\r\n\r\n    if (params.stock) {\r\n        productsQuery = productsQuery.gt(\"stock\", 0)\r\n    }\r\n\r\n    if (params.sort === \"price-asc\") productsQuery = productsQuery.order(\"precio\", { ascending: true })\r\n    if (params.sort === \"price-desc\") productsQuery = productsQuery.order(\"precio\", { ascending: false })\r\n    if (params.sort === \"name-asc\") productsQuery = productsQuery.order(\"nombre\", { ascending: true })\r\n    if (params.sort === \"name-desc\") productsQuery = productsQuery.order(\"nombre\", { ascending: false })\r\n    if (params.sort === \"newest\") productsQuery = productsQuery.order(\"created_at\", { ascending: false })\r\n\r\n    const from = Math.max(0, (params.page - 1) * params.pageSize)\r\n    const to = Math.max(from, from + params.pageSize - 1)\r\n    productsQuery = productsQuery.range(from, to)\r\n\r\n    const { data, error, count } = await productsQuery\r\n\r\n    if (error) {\r\n        console.error(\"Error fetching products:\", error)\r\n        return { productos: [], totalCount: 0 }\r\n    }\r\n\r\n    return {\r\n        productos: (data as Product[]) || [],\r\n        totalCount: Number(count || 0),\r\n    }\r\n}\r\n\r\nexport type CountProductsParams = {\r\n    cat: string\r\n    q: string\r\n    min: string\r\n    max: string\r\n    stock: boolean\r\n}\r\n\r\nexport async function countProducts(params: CountProductsParams): Promise<number | null> {\r\n    const q = (params.q || \"\").trim()\r\n    const min = params.min ? Number(params.min) : null\r\n    const max = params.max ? Number(params.max) : null\r\n\r\n    let countQuery = supabase.from(\"productos\").select(\"id\", { count: \"exact\", head: true })\r\n\r\n    if (params.cat !== \"all\") {\r\n        const categoryId = Number(params.cat)\r\n        if (Number.isFinite(categoryId) && categoryId > 0) {\r\n            countQuery = countQuery.eq(\"categoria_id\", categoryId)\r\n        } else {\r\n            const { data: catRow, error: catError } = await supabase\r\n                .from(\"categorias\")\r\n                .select(\"id\")\r\n                .eq(\"slug\", params.cat)\r\n                .maybeSingle()\r\n\r\n            if (!catError && catRow?.id) {\r\n                countQuery = countQuery.eq(\"categoria_id\", catRow.id)\r\n            }\r\n        }\r\n    }\r\n\r\n    if (q) {\r\n        countQuery = countQuery.ilike(\"nombre\", `%${q}%`)\r\n    }\r\n\r\n    if (min !== null && Number.isFinite(min)) {\r\n        countQuery = countQuery.gte(\"precio\", min)\r\n    }\r\n\r\n    if (max !== null && Number.isFinite(max)) {\r\n        countQuery = countQuery.lte(\"precio\", max)\r\n    }\r\n\r\n    if (params.stock) {\r\n        countQuery = countQuery.gt(\"stock\", 0)\r\n    }\r\n\r\n    const { count, error } = await countQuery\r\n    if (error) {\r\n        console.error(\"Error fetching draft count:\", error)\r\n        return null\r\n    }\r\n\r\n    return Number(count || 0)\r\n}\r\n\r\nexport type ProductDetailResult = {\r\n    producto: ProductWithCategory | null\r\n    variantes: ProductVariant[]\r\n    especificaciones: ProductSpecification[]\r\n}\r\n\r\nexport async function getProductDetail(productId: number): Promise<ProductDetailResult> {\r\n    const [prodRes, variantsRes, specsRes] = await Promise.all([\r\n        supabase.from(\"productos\").select(`*, categorias (id, nombre, slug)`).eq(\"id\", productId).single(),\r\n        supabase\r\n            .from(\"producto_variantes\")\r\n            .select(\"*\")\r\n            .eq(\"producto_id\", productId)\r\n            .eq(\"activo\", true)\r\n            .order(\"id\", { ascending: true }),\r\n        supabase\r\n            .from(\"producto_especificaciones\")\r\n            .select(\"*\")\r\n            .eq(\"producto_id\", productId)\r\n            .order(\"orden\", { ascending: true })\r\n            .order(\"id\", { ascending: true }),\r\n    ])\r\n\r\n    const { data, error } = prodRes\r\n\r\n    const producto = error ? null : ((data as ProductWithCategory) || null)\r\n\r\n    const variantes = Array.isArray(variantsRes.data) ? (variantsRes.data as ProductVariant[]) : []\r\n    const especificaciones = Array.isArray(specsRes.data)\r\n        ? (specsRes.data as ProductSpecification[])\r\n        : []\r\n\r\n    if (error) {\r\n        console.error(\"Error fetching producto:\", error)\r\n    }\r\n\r\n    return {\r\n        producto,\r\n        variantes,\r\n        especificaciones,\r\n    }\r\n}\r\n\r\nexport async function getRecommendedProducts(excludeId: number): Promise<any[]> {\r\n    try {\r\n        const { data: topData, error: topError } = await supabase.rpc(\"get_top_products\", {\r\n            limit_count: 8,\r\n            exclude_id: excludeId,\r\n        })\r\n\r\n        if (!topError && Array.isArray(topData)) {\r\n            return topData\r\n        }\r\n\r\n        const { data: recentData, error: recentError } = await supabase\r\n            .from(\"productos\")\r\n            .select(\"*\")\r\n            .neq(\"id\", excludeId)\r\n            .gt(\"stock\", 0)\r\n            .order(\"created_at\", { ascending: false })\r\n            .limit(8)\r\n\r\n        if (!recentError && Array.isArray(recentData)) {\r\n            return recentData\r\n        }\r\n\r\n        return []\r\n    } catch (err) {\r\n        return []\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}