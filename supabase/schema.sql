
-- Enable necessary extensions if needed
-- create extension if not exists "uuid-ossp";

-- Categorias
create table if not exists categorias (
  id bigint generated by default as identity primary key,
  nombre text not null,
  slug text not null unique,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Productos
create table if not exists productos (
  id bigint generated by default as identity primary key,
  nombre text not null,
  precio numeric not null,
  precio_antes numeric,
  descripcion text,
  materiales text,
  tamano text,
  color text,
  cuidados text,
  uso text,
  stock integer not null default 0,
  imagen_url text,
  imagenes text[],
  videos text[],
  categoria_id bigint references categorias(id) on delete set null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table productos add column if not exists precio_antes numeric;

alter table productos add column if not exists descripcion text;
alter table productos add column if not exists materiales text;
alter table productos add column if not exists tamano text;
alter table productos add column if not exists color text;
alter table productos add column if not exists cuidados text;
alter table productos add column if not exists uso text;

alter table productos add column if not exists videos text[];

-- Variantes
create table if not exists producto_variantes (
  id bigint generated by default as identity primary key,
  producto_id bigint not null references productos(id) on delete cascade,
  etiqueta text not null,
  talla text,
  color text,
  modelo text,
  precio numeric,
  precio_antes numeric,
  stock integer not null default 0,
  activo boolean not null default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists producto_variantes_producto_id_idx on public.producto_variantes (producto_id);

-- Especificaciones (ficha tÃ©cnica)
create table if not exists producto_especificaciones (
  id bigint generated by default as identity primary key,
  producto_id bigint not null references productos(id) on delete cascade,
  clave text not null,
  valor text,
  orden integer not null default 0,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists producto_especificaciones_producto_id_idx on public.producto_especificaciones (producto_id);

-- Clientes
create table if not exists clientes (
  id bigint generated by default as identity primary key,
  nombre text not null,
  telefono text,
  dni text,
  direccion text,
  es_problematico boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table clientes add column if not exists dni text;

-- Pedidos
create table if not exists pedidos (
  id bigint generated by default as identity primary key,
  cliente_id bigint references clientes(id) on delete set null,
  total numeric not null,
  stock_descontado boolean not null default false,
  status text check (status in ('Pendiente', 'Confirmado', 'Preparando', 'Enviado', 'Entregado', 'Fallido', 'Devuelto')) default 'Pendiente',
  pago_status text check (pago_status in ('Pendiente', 'Pagado Anticipado', 'Pago Contraentrega', 'Pagado al Recibir')) default 'Pendiente',
  voucher_url text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Pedido Items
create table if not exists pedido_items (
  id bigint generated by default as identity primary key,
  pedido_id bigint references pedidos(id) on delete cascade,
  producto_id bigint references productos(id) on delete set null,
  producto_variante_id bigint references producto_variantes(id) on delete set null,
  precio_unitario numeric,
  producto_nombre text,
  variante_nombre text,
  cantidad integer not null
);

-- Incidencias
create table if not exists incidencias (
  id bigint generated by default as identity primary key,
  pedido_id bigint references pedidos(id) on delete cascade,
  tipo text,
  comentario text,
  foto text,
  fotos text[],
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create table if not exists cupones (
  id bigint generated by default as identity primary key,
  codigo text not null unique,
  tipo text not null default 'porcentaje' check (tipo in ('porcentaje', 'monto')),
  valor numeric not null,
  activo boolean not null default true,
  min_total numeric not null default 0,
  max_usos integer,
  usos integer not null default 0,
  starts_at timestamp with time zone,
  expires_at timestamp with time zone,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table pedidos add column if not exists subtotal numeric;
alter table pedidos add column if not exists descuento numeric default 0;
alter table pedidos add column if not exists cupon_codigo text;
alter table pedidos add column if not exists stock_descontado boolean not null default false;

alter table incidencias add column if not exists fotos text[];

create table if not exists home_banners (
  id bigint generated by default as identity primary key,
  title text,
  subtitle text,
  cta text,
  href text not null,
  orden integer not null default 0,
  activo boolean not null default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table home_banners enable row level security;

drop policy if exists home_banners_read on public.home_banners;
drop policy if exists home_banners_insert on public.home_banners;
drop policy if exists home_banners_update on public.home_banners;
drop policy if exists home_banners_delete on public.home_banners;

create policy home_banners_read
on public.home_banners
for select
using (true);

create policy home_banners_insert
on public.home_banners
for insert
to authenticated
with check (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

insert into storage.buckets (id, name, public)
values ('review_photos', 'review_photos', true)
on conflict (id) do nothing;

insert into storage.buckets (id, name, public)
values ('productos', 'productos', true)
on conflict (id) do nothing;

drop policy if exists review_photos_read on storage.objects;

drop policy if exists productos_read on storage.objects;
drop policy if exists productos_write_admin on storage.objects;

create policy review_photos_read
on storage.objects
for select
using (bucket_id = 'review_photos');

create policy productos_read
on storage.objects
for select
using (bucket_id = 'productos');

create policy productos_write_admin
on storage.objects
for all
to authenticated
using (
  bucket_id = 'productos'
  and exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
)
with check (
  bucket_id = 'productos'
  and exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy home_banners_update
on public.home_banners
for update
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy home_banners_delete
on public.home_banners
for delete
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create table if not exists product_reviews (
  id bigint generated by default as identity primary key,
  product_id bigint not null references productos(id) on delete cascade,
  rating integer not null check (rating >= 1 and rating <= 5),
  title text,
  body text not null,
  customer_name text,
  customer_city text,
  photo_urls text[],
  order_id bigint references pedidos(id) on delete set null,
  verified boolean not null default false,
  approved boolean not null default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists product_reviews_product_id_idx on public.product_reviews (product_id);
create index if not exists product_reviews_product_id_approved_idx on public.product_reviews (product_id, approved);

alter table public.product_reviews enable row level security;

drop policy if exists product_reviews_read_public on public.product_reviews;
drop policy if exists product_reviews_read_admin on public.product_reviews;
drop policy if exists product_reviews_write_admin on public.product_reviews;

create policy product_reviews_read_public
on public.product_reviews
for select
using (approved = true);

create policy product_reviews_read_admin
on public.product_reviews
for select
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy product_reviews_write_admin
on public.product_reviews
for all
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create table if not exists product_questions (
  id bigint generated by default as identity primary key,
  product_id bigint not null references productos(id) on delete cascade,
  question text not null,
  asker_name text,
  asker_phone text,
  published boolean not null default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists product_questions_product_id_idx on public.product_questions (product_id);
create index if not exists product_questions_product_id_published_idx on public.product_questions (product_id, published);

alter table public.product_questions enable row level security;

drop policy if exists product_questions_read_public on public.product_questions;
drop policy if exists product_questions_read_admin on public.product_questions;
drop policy if exists product_questions_write_admin on public.product_questions;

create policy product_questions_read_public
on public.product_questions
for select
using (published = true);

create policy product_questions_read_admin
on public.product_questions
for select
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy product_questions_write_admin
on public.product_questions
for all
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create table if not exists product_answers (
  id bigint generated by default as identity primary key,
  question_id bigint not null references product_questions(id) on delete cascade,
  answer text not null,
  answered_by text,
  published boolean not null default true,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

create index if not exists product_answers_question_id_idx on public.product_answers (question_id);

alter table public.product_answers enable row level security;

drop policy if exists product_answers_read_public on public.product_answers;
drop policy if exists product_answers_read_admin on public.product_answers;
drop policy if exists product_answers_write_admin on public.product_answers;

create policy product_answers_read_public
on public.product_answers
for select
using (
  published = true
  and exists (
    select 1
    from public.product_questions q
    where q.id = question_id
      and q.published = true
  )
);

create policy product_answers_read_admin
on public.product_answers
for select
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);

create policy product_answers_write_admin
on public.product_answers
for all
to authenticated
using (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
)
with check (
  exists (
    select 1
    from public.profiles p
    where p.id = auth.uid()
      and p.role = 'admin'
  )
);
